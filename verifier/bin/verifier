#!/usr/bin/env node
/*eslint no-console: 0*/
'use strict';

var queue = require('../src/queue');
var verifier = require('../src/verifier');

const FBSECRET = process.env.SINGPATH_FIREBASE_SECRET;
const FBENDPOINT = process.env.SINGPATH_FIREBASE_QUEUE;

const BINNAME = process.argv[1].split('/').pop();
const USAGE = `
Monitor a SingPath.com task queue for new task to run.

Usage: ${BINNAME}

Environment:
  The following environment variable must be defined.

  SINGPATH_FIREBASE_QUEUE    Defines the queue to push task to.

  SINGPATH_FIREBASE_SECRET   Defines the Firebase secret to use to create auth
                    token.

`;

function main() {
  let q, generator, authToken;

  if (!FBENDPOINT) {
    console.error('Firebase queue path is missing. Please set the SINGPATH_FIREBASE_QUEUE environment variable.');
    console.error(USAGE);
    process.exit(128);
  } else if (!FBSECRET) {
    console.error('Firebase secret is missing. Please the SINGPATH_FIREBASE_SECRET environment variable.');
    console.error(USAGE);
    process.exit(129);
  } else {
    console.log(`Will use queue at ${FBENDPOINT}`);
  }

  const lastArgument = process.argv.slice().pop();
  if (['-h', '-help', '--help', 'help'].indexOf(lastArgument) > -1 ) {
    console.error(USAGE);
    process.exit(0);
  }


  verifier.dockerClient().then(client => {
    q = queue.queue(FBENDPOINT, client);
    logEvents(q);
  }).then(() => {
    console.log('Generating auth token...');
    generator = queue.tokenGenerator(FBSECRET);
    authToken = generator.worker(q.queueName);

    console.log('Authenticating client...');
    return q.auth(authToken);
  }).then(() => {
    return q.watch();
  }).catch(err => {
    console.error(err);
    process.exit(130);
  });
}

function logEvents(q) {
  q.on('loggedIn', authData => console.error(`logged with ${JSON.stringify(authData)}.`));
  q.on('loggedOut', authData => console.error(`logged out (${authData}).`));
  q.on('workerRegistered', () => console.error('worker registered.'));
  q.on('workerRemoved', () => console.error('worker de-registered.'));
  q.on('workerPresenceUpdated', () => console.error('worker updated.'));
  q.on('workerPresenceUpdateFailed', err => console.error(`worker update failed ${err.toString()}.`));
  q.on('workerPresenceUpdateStopped', () => console.error('worker updates stopped.'));
  q.on('watchStarted', () => console.error('watch started.'));
  q.on('watchStopped', err => {
    console.error(`Watch stopped: ${err.toString()}.`);
    process.exit(131);
  });
  q.on('taskRunScheduled', (key, task) => console.error(`Task schedule (${key}): ${JSON.stringify(task)}.`));
  q.on('taskClaimed', key => console.error(`Task ${key} claimed.`));
  q.on('taskRun', (key, results) => console.error(`Task ${key} run: ${JSON.stringify(results)}.`));
  q.on('taskRunFailed', (key, err) => console.error(`Failed to run ${key}: ${err.toString()}.`));
  q.on('taskClaimRemoved', key => console.error(`Task claim on ${key} removed.`));
  q.on('taskClaimRemovalFailed', key => console.error(`Task claim on ${key} failed to be removed .`));
}


if (require.main === module) {
  main();
}
