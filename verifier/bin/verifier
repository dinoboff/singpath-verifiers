#!/usr/bin/env node
/*eslint no-console: 0*/
'use strict';

const queue = require('../src/queue');
const verifier = require('../src/verifier');
const util = require('util');


const FBSECRET = process.env.SINGPATH_FIREBASE_SECRET;
const FBENDPOINT = process.env.SINGPATH_FIREBASE_QUEUE;

const BINNAME = process.argv[1].split('/').pop();
const USAGE = `
Monitor a SingPath.com task queue for new task to run.

Usage: ${BINNAME}

Environment:
  The following environment variable must be defined.

  SINGPATH_FIREBASE_QUEUE    Defines the queue to push task to.

  SINGPATH_FIREBASE_SECRET   Defines the Firebase secret to use to create auth
                    token.

`;

const DEBUG = 10;
const INFO = 20;
const ERROR = 30;

class Logger {

  constructor(stream, level) {
    this.stream = stream;
    this.level = level || DEBUG;
  }

  now() {
    return new Date().toISOString().replace('T', ' ').slice(0, -1);
  }

  _write(args) {
    this.stream.write(util.format.apply(util, args));
  }

  _log(args, level) {
    args = Array.from(args);

    if (level < this.level) {
      return;
    }

    if (args.length < 1) {
      return;
    }

    args[0] = `${this.now()} - ${args[0]}\n`;
    this._write(args);
  }

  log() {
    this._log(arguments, INFO);
  }

  info() {
    this._log(arguments, INFO);
  }

  error() {
    this._log(arguments, ERROR);
  }

  warn() {
    this._log(arguments, ERROR);
  }

  debug() {
    this._log(arguments, DEBUG);
  }
}

function main() {
  const logger = new Logger(process.stderr);

  if (!FBENDPOINT) {
    logger.error('Firebase queue path is missing. Please set the SINGPATH_FIREBASE_QUEUE environment variable.');
    logger.error(USAGE);
    process.exit(128);
  } else if (!FBSECRET) {
    logger.error('Firebase secret is missing. Please the SINGPATH_FIREBASE_SECRET environment variable.');
    logger.error(USAGE);
    process.exit(129);
  } else {
    logger.info('Using queue at %s', FBENDPOINT);
  }

  const lastArgument = process.argv.slice().pop();
  if (['-h', '-help', '--help', 'help'].indexOf(lastArgument) > -1 ) {
    logger.error(USAGE);
    process.exit(0);
  }


  verifier.dockerClient().then(
    client => queue.queue(FBENDPOINT, client, logger)
  ).then(q => {
    logEvents(q, logger);
    q.on('watchStopped', err => {
      if (err == null) {
        q.cleanup().then(
          () => process.exit(131),
          () => process.exit(131)
        );
      }

      watch(q, logger);
    });
    return watch(q, logger);
  });
}

function watch(q, logger) {
  logger.info('Generating auth token...');

  const generator = queue.tokenGenerator(FBSECRET);
  const authToken = generator.worker(q.queueName);

  logger.info('Authenticating client...');
  return q.auth(authToken).then(
    () => q.cleanUp()
  ).then(
    () => q.watch()
  ).catch(err => {
    logger.error(err);
    process.exit(130);
  });
}

function logEvents(q, logger) {
  q.on('loggedIn', authData => logger.error('logged with "%j"', authData));
  q.on('loggedOut', authData => logger.error('logged out ("%j")', authData));
}


if (require.main === module) {
  main();
}
