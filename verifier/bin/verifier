#!/usr/bin/env node
/*eslint no-console: 0*/
'use strict';

var queue = require('../src/queue');
var verifier = require('../src/verifier');

const FBSECRET = process.env.SINGPATH_FIREBASE_SECRET;
const FBENDPOINT = process.env.SINGPATH_FIREBASE_QUEUE;

const BINNAME = process.argv[1].split('/').pop();
const USAGE = `
Monitor a SingPath.com task queue for new task to run.

Usage: ${BINNAME}

Environment:
  The following environment variable must be defined.

  SINGPATH_FIREBASE_QUEUE    Defines the queue to push task to.

  SINGPATH_FIREBASE_SECRET   Defines the Firebase secret to use to create auth
                    token.

`;

function main() {
  if (!FBENDPOINT) {
    console.error('Firebase queue path is missing. Please set the SINGPATH_FIREBASE_QUEUE environment variable.');
    console.error(USAGE);
    process.exit(128);
  } else if (!FBSECRET) {
    console.error('Firebase secret is missing. Please the SINGPATH_FIREBASE_SECRET environment variable.');
    console.error(USAGE);
    process.exit(129);
  } else {
    console.log(`Will use queue at ${FBENDPOINT}`);
  }

  const lastArgument = process.argv.slice().pop();
  if (['-h', '-help', '--help', 'help'].indexOf(lastArgument) > -1 ) {
    console.error(USAGE);
    process.exit(0);
  }


  verifier.dockerClient().then(
    client => queue.queue(FBENDPOINT, client)
  ).then(q => {
    logEvents(q);
    q.on('watchStopped', err => {
      if (err == null) {
        q.cleanup().then(
          () => process.exit(131),
          () => process.exit(131)
        );
      }

      watch(q);
    });
    return watch(q);
  });
}

function watch(q) {
  console.log('Generating auth token...');

  const generator = queue.tokenGenerator(FBSECRET);
  const authToken = generator.worker(q.queueName);

  console.log('Authenticating client...');
  return q.auth(authToken).then(
    () => q.cleanUp()
  ).then(
    () => q.watch()
  ).catch(err => {
    console.error(err);
    process.exit(130);
  });
}

function logEvents(q) {
  // TODO: set up logger and replace most of the event - only "watchStopped" is
  // useful.
  q.on('loggedIn', authData => console.error(`logged with ${JSON.stringify(authData)}.`));
  q.on('loggedOut', authData => console.error(`logged out (${authData}).`));
  q.on('workerRegistered', () => console.error('worker registered.'));
  q.on('workerRemoved', () => console.error('worker de-registered.'));
  q.on('workerPresenceUpdated', () => console.error('worker updated.'));
  q.on('workerPresenceUpdateFailed', err => console.error(`worker update failed ${err.toString()}.`));
  q.on('workerPresenceUpdateStopped', () => console.error('worker updates stopped.'));
  q.on('watchStarted', () => console.error('watch started.'));
  q.on('watchStopped', err => console.error(`Watch stopped: ${err.toString()}.`));
  q.on('taskRunScheduled', (key, task) => console.error(`Task schedule (${key}): ${JSON.stringify(task)}.`));
  q.on('taskClaimed', key => console.error(`Task ${key} claimed.`));
  q.on('taskClaimFailed', (key, err) => console.error(`Task ${key} claim failed: ${err.toString()}.`));
  q.on('taskRun', (key, results) => console.error(`Task ${key} run: ${JSON.stringify(results)}.`));
  q.on('taskResultSave', (key) => console.error(`Task ${key} saved.`));
  q.on('taskResultSavingFailed', (key) => console.error(`Failed to save task ${key}.`));
  q.on('taskRunFailed', (key, err) => console.error(`Failed to run ${key}: ${err.toString()}.`));
  q.on('taskClaimRemoved', key => console.error(`Task claim on ${key} removed.`));
  q.on('taskClaimRemovalFailed', key => console.error(`Task claim on ${key} failed to be removed .`));
}


if (require.main === module) {
  main();
}
