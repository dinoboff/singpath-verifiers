#!/usr/bin/env node
/*eslint no-console: 0*/
'use strict';

const queue = require('../src/queue');
const yaml = require('js-yaml');

const FB_SECRET = process.env.SINGPATH_FIREBASE_SECRET;
const FB_ENDPOINT = process.env.SINGPATH_FIREBASE_QUEUE;
const FB_USER_ID = process.env.SINGPATH_PUSH_USER_ID || '#1';

const BINNAME = process.argv[1].split('/').pop();
const USAGE = `
Usage: ${BINNAME} YAMLsolutions

Example:

  The following will push one solution to a queue:

    ${BINNAME} '---
    language: java
    tests: |
      SingPath sp = new SingPath();
      assertEquals(2.0 , sp.add());
    solution: |
      public class SingPath {
        public Double add() {
          return 2.0;
        }
      }
    '

  The following will push the solutions defined in "solutions.yaml":

    ${BINNAME} "$(< solutions.yaml)"

Environment:
  The following environment variable must be defined.

  SINGPATH_FIREBASE_QUEUE    Defines the queue to push task to.

  SINGPATH_FIREBASE_SECRET   Defines the Firebase secret to use to create auth
                    token.

`;

function loadSolutions(yamlString) {
  let docs = [];

  console.log('Parsing solutions to push...');
  console.log(yamlString);
  yaml.safeLoadAll(yamlString, doc => {
    let language = doc.language;
    let tests = doc.tests;
    let solution = doc.solution;

    if (!language || !tests || !solution) {
      console.error(
        'The verifier requires a language, some tests and a solution. Got: %s',
        doc
      );
      return;
    }

    docs.push({language, tests, solution});
  });

  return docs;
}

function pushSolutions(q, solutions) {
  let operations = solutions.map(payload => {
    console.log('Pushing solution... ');
    return q.pushToQueue(payload).then(
      ref => console.log('Solution pushed at %s', ref.toString())
    );
  });

  let failure = 0;

  // recover any rejected push operation and count the number of failure
  return Promise.all(
    operations.map(
      op => op.catch(err => console.error('Push failed: %s', err))
    )
  ).then(
    () => failure
  );
}

function main() {
  let q, input, solutions, generator, authToken;

  if (!FB_ENDPOINT) {
    console.error('Firebase queue path is missing. Please set the SINGPATH_FIREBASE_QUEUE environment variable.');
    process.exit(128);
  } else if (!FB_SECRET) {
    console.error('Firebase secret is missing. Please the SINGPATH_FIREBASE_SECRET environment variable.');
    process.exit(129);
  } else {
    console.log(`Will use queue at ${FB_ENDPOINT}`);
    q = queue.queue(FB_ENDPOINT);
  }

  input = process.argv.pop();
  if (!input) {
    console.error(USAGE);
    process.exit(130);
  }

  console.log('parsing yaml encoded solutions');
  solutions = loadSolutions(input);
  if (solutions.length < 0) {
    console.error('no solution to push');
    process.exit(131);
  }

  console.log('Generating auth token...');
  generator = queue.tokenGenerator(FB_SECRET);
  authToken = generator.user(FB_USER_ID);

  console.log('Authenticating client...');
  return q.auth(authToken).then(() => {
    // We need to exit or the firebase connection will keep the process running.
    return pushSolutions(q, solutions).then(
      failures => process.exit(failures)
    );
  }).catch( err => {
    console.error('Unexpected error: %s', err);
    process.exit(1);
  });
}


if (require.main === module) {
  main();
}
